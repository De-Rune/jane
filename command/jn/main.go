package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/De-Rune/jane/package/io"
	"github.com/De-Rune/jane/package/jn"
	"github.com/De-Rune/jane/package/jn/jnset"
	"github.com/De-Rune/jane/parser"
)

func help(cmd string) {
	if cmd != "" {
		println("this module can only by used as a single")
		return
	}
	helpContent := [][]string{
		{"help", "show help"},
		{"version", "show version"},
		{"init", "initialize project jane"},
	}
	maxlen := len(helpContent[0][0])
	for _, part := range helpContent {
		length := len(part[0])
		if length > maxlen {
			maxlen = length
		}
	}
	var sb strings.Builder
	const space = 5
	for _, part := range helpContent {
		sb.WriteString(part[0])
		sb.WriteString(strings.Repeat(" ", (maxlen-len(part[0]))+space))
		sb.WriteString(part[1])
		sb.WriteByte('\n')
	}
	println(sb.String()[:sb.Len()-1])
}

func version(cmd string) {
	if cmd != "" {
		println("this module can only by used as a single")
		return
	}
	println("Jane Programming language\n" + jn.Version)
}

func initProject(cmd string) {
	if cmd != "" {
		println("this module can only by used as a single")
		return
	}
	content := []byte(`{
		"cxx_out_dir": "./dist/",
		"cxx_out_name": "jn.cxx",
		"out_name": "main"
	  }`)
	err := ioutil.WriteFile(jn.SettingsFile, content, 0666)
	if err != nil {
		println(err.Error())
		os.Exit(0)
	}
	println("initialized project")
}

func processCommand(namespace, cmd string) bool {
	switch namespace {
	case "help":
		help(cmd)
	case "version":
		version(cmd)
	case "init":
		initProject(cmd)
	default:
		return false
	}
	return true
}

func init() {
	jn.ExecutablePath = filepath.Dir(os.Args[0])
	if len(os.Args) < 2 {
		os.Exit(0)
	}
	var sb strings.Builder
	for _, arg := range os.Args[1:] {
		sb.WriteString(" " + arg)
	}
	os.Args[0] = sb.String()[1:]
	arg := os.Args[0]
	index := strings.Index(arg, " ")
	if index == -1 {
		index = len(arg)
	}
	if processCommand(arg[:index], arg[index:]) {
		os.Exit(0)
	}
}

func loadJnSet() {
	info, err := os.Stat(jn.SettingsFile)
	if err != nil || info.IsDir() {
		println(`jn settings file ("` + jn.SettingsFile + `") is not found`)
		os.Exit(0)
	}
	bytes, err := os.ReadFile(jn.SettingsFile)
	if err != nil {
		println(err.Error())
		os.Exit(0)
	}
	jn.JnSet, err = jnset.Load(bytes)
	if err != nil {
		println("jn settings has error")
		println(err.Error())
		os.Exit(0)
	}
}

func printErrors(errors []string) {
	defer os.Exit(0)
	for _, message := range errors {
		fmt.Println(message)
	}
}

func appendStandards(code *string) {
	year, month, day := time.Now().Date()
	hour, min, _ := time.Now().Clock()
	timeString := fmt.Sprintf("%d/%d/%d %d.%d (DD/MM/YYYY) (HH.MM)", day, month, year, hour, min)
	*code = `// JN compiler version:		` + jn.Version + `
// Date: 					` + timeString + `
// Author:  				` + jn.Author + `
// License: 				` + jn.License + `

// this file contains cxx module code which is automatically generated by JN compiler.
// generated code in this file provide cxx functions and structures corresponding to the definition
// in the JN source files

// region JN_STANDARD_IMPORTS
#include <cstdint>
#include <functional>
#include <iostream>
#include <locale.h>
#include <string>
#include <vector>
// endregion JN_STANDARD_IMPORTS

// region JN_BUILTIN_VALUES
#define nil nullptr
// endregion JN_BUILTIN_VALUES

// region JN_CXX_API
#define JNALLOC(_Alloc) new (std::nothrow) _Alloc
#define panic(_Msg)                                                            \
  std::wcout << _Msg << std::endl;                                             \
  std::exit(EXIT_FAILURE)

template <typename _Enum_t, typename _Index_t, typename _Item_t>
static inline void foreach (
    const _Enum_t _Enum, const std::function<void(_Index_t, _Item_t)> _Body) {
  _Index_t _index{0};
  for (auto _item : _Enum) {
    _Body(_index++, _item);
  }
}

template <typename _Enum_t, typename _Index_t>
static inline void foreach (const _Enum_t _Enum,
                            const std::function<void(_Index_t)> _Body) {
  _Index_t _index{0};
  for (auto _ : _Enum) {
    _Body(_index++);
  }
}
// endregion JN_CXX_API

// region JN_BUILTIN_TYPES
typedef size_t size;
typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;
typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;
typedef float f32;
typedef double f64;
typedef wchar_t rune;

class str {
public:
  // region FIELDS
  rune *_buffer{nil};
  size _length{0};
  // endregion FIELDS

  // region CONSTRUCTOR
  str(void) {
    this->_buffer = {JNALLOC(rune)};
    if (!this->_buffer) {
      panic(L"string memory allocation is failed");
    }
  }

  str(const rune *_Str) {
    this->_buffer = wcsdup(_Str);
    this->_length = wcslen(this->_buffer);
  }
  // endregion CONSTRUCTORS

  // region DESTRUCTOR
  ~str(void) {
    delete this->_buffer;
    this->_buffer = nil;
  }
  // endregion DESTRUCTOR

  // region FOREACH_SUPPORT
  typedef rune *iterator;
  typedef const rune *const_iterator;
  iterator begin(void) { return &this->_buffer[0]; }
  const_iterator begin(void) const { return &this->_buffer[0]; }
  iterator end(void) { return &this->_buffer[this->_length]; }
  const_iterator end(void) const { return &this->_buffer[this->_length]; }
  // endregion FOREACH_SUPPORT

  // region OPERATOR_OVERFLOWS
  bool operator==(const str &_Str) {
    return wcscmp(this->_buffer, _Str._buffer) == 0;
  }
  bool operator!=(const str &_Str) {
    return wcscmp(this->_buffer, _Str._buffer) != 0;
  }
  str operator+(const str &_Str) {
    return str(wcscat(this->_buffer, _Str._buffer));
  }
  void operator+=(const str &_Str) {
    this->_buffer = wcscat(this->_buffer, _Str._buffer);
  }

  rune &operator[](const int _Index) {
    if (_Index < 0) {
      panic(L"stackoverflow exception:\n index is less than zero");
    } else if (_Index >= this->_length) {
      panic(L"stackoverflow exception:\nindex overflow " +
            std::to_wstring(_Index) + L":" + std::to_wstring(this->_length));
    }
    return this->_buffer[_Index];
  }

  friend std::wostream &operator<<(std::wostream &_Stream, const str &_Str) {
    return _Stream << _Str._buffer;
  }
  // endregion OPERATOR_OVERFLOWS
};
// endregion JN_BUILTIN_TYPES

// region JN_STRUCTURES
template <typename _Item_t> class array {
public:
  // region FIELDS
  std::vector<_Item_t> _buffer;
  // endregion FIELDS

  // region CONSTRUCTORS
  array<_Item_t>(void) { this->_buffer = {}; }
  array<_Item_t>(const std::vector<_Item_t> &_Src) { this->_buffer = _Src; }
  array<_Item_t>(std::nullptr_t) : array<_Item_t>() {}
  array<_Item_t>(const array<_Item_t> &_Src) : array<_Item_t>(_Src._buffer) {}
  // endregion CONSTRUCTORS

  // region DESTRUCTOR
  ~array<_Item_t>(void) { this->_buffer.clear(); }
  // endregion DESTRUCTOR

  // region FOREACH_SUPPORT
  typedef _Item_t *iterator;
  typedef const _Item_t *const_iterator;
  iterator begin(void) { return &this->_buffer[0]; }
  const_iterator begin(void) const { return &this->_buffer[0]; }
  iterator end(void) { return &this->_buffer[this->_buffer.size()]; }
  const_iterator end(void) const {
    return &this->_buffer[this->_buffer.size()];
  }
  // endregion FOREACH_SUPPORT

  // region OPERATOR_OVERFLOWS
  bool operator==(const array<_Item_t> &_Src) {
    const size _length = this->_buffer.size();
    const size _Src_length = _Src._buffer.size();
    if (_length != _Src_length) {
      return false;
    }
    for (size _index = 0; _index < _length; ++_index) {
      if (this->_buffer[_index] != _Src._buffer[_index]) {
        return false;
      }
    }
    return true;
  }

  bool operator==(std::nullptr_t) { return this->_buffer.empty(); }
  bool operator!=(const array<_Item_t> &_Src) { return !(*this == _Src); }
  bool operator!=(std::nullptr_t) { return !this->_buffer.empty(); }

  _Item_t &operator[](const int _Index) {
    const size _length = this->_buffer.size();
    if (_Index < 0) {
      panic(L"stackoverflow exception:\n index is less than zero");
    } else if (_Index >= _length) {
      panic(L"stackoverflow exception:\nindex overflow " +
            std::to_wstring(_Index) + L":" + std::to_wstring(_length));
    }
    return this->_buffer[_Index];
  }

  friend std::wostream &operator<<(std::wostream &_Stream,
                                   const array<_Item_t> &_Src) {
    _Stream << L"[";
    const size _length = _Src._buffer.size();
    for (size _index = 0; _index < _length;) {
      _Stream << _Src._buffer[_index++];
      if (_index < _length) {
        _Stream << L", ";
      }
    }
    _Stream << L"]";
    return _Stream;
  }
  // endregion OPERATOR_OVERFLOWS
};
// endregion JN_STRUCTURES

// region JN_BUILTIN_FUNCTIONS
#define _print(_Obj) std::wcout << _Obj
#define _println(_Obj)                                                         \
  _print(_Obj);                                                                \
  std::wcout << std::endl
// endregion JN_BUILTIN_FUNCTIONS

// region TRANSPILED_JN_CODE
` + *code + `
// endregion TRANSPILED_JN_CODE

// region JN_ENTRY_POINT
int main() {
  // region JN_ENTRY_POINT_STANDARD_CODES
  std::setlocale(LC_ALL, "");
  // endregion JN_ENTRY_POINT_STANDARD_CODES
  _main();

  // region JN_ENTRY_POINT_END_STANDARD_CODES
  return EXIT_SUCCESS;
  // endregion JN_ENTRY_POINT_END_STANDARD_CODES
}
// endregion JN_ENTRY_POINT`
}

func writeCxxOutput(info *parser.ParseFileInfo) {
	path := filepath.Join(jn.JnSet.CxxOutDir, jn.JnSet.CxxOutName)
	err := os.MkdirAll(jn.JnSet.CxxOutDir, 0777)
	if err != nil {
		println(err.Error())
		os.Exit(0)
	}
	content := []byte(info.JN_CXX)
	err = os.WriteFile(path, content, 0666)
	if err != nil {
		println(err.Error())
		os.Exit(0)
	}
}

var routines *sync.WaitGroup

func main() {
	f, err := io.GetJn(os.Args[0])
	if err != nil {
		println(err.Error())
		return
	}
	loadJnSet()
	routines = new(sync.WaitGroup)
	info := new(parser.ParseFileInfo)
	info.File = f
	info.Routines = routines
	routines.Add(1)
	go parser.ParseFileAsync(info)
	routines.Wait()
	if info.Errors != nil {
		printErrors(info.Errors)
	}
	appendStandards(&info.JN_CXX)
	writeCxxOutput(info)
}
